<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Archivio Clienti - Trasporti</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Manifest: percorso per Netlify -->
  <link rel="manifest" href="./manifest.json">

  <style>
    :root { --bg:#f9f9f9; --card:#fff; --txt:#222; --muted:#666; --brand:#007bff; }
    body { font-family: Arial, sans-serif; padding: 15px; margin: 0; background-color: var(--bg); color:var(--txt); }
    h1 { font-size: 22px; margin-bottom: 10px; }
    input, textarea, button, select { margin: 6px 0; width: 100%; padding: 10px; font-size: 16px; box-sizing: border-box; }
    textarea { resize: vertical; }
    #clienti { margin-top: 20px; }
    .cliente { border: 1px solid #ddd; padding: 12px; margin-bottom: 12px; border-radius: 8px; background-color: var(--card); }
    .btn-azione { margin-top: 8px; margin-right: 5px; font-size: 14px; padding: 6px 10px; }
    .avviso { background-color: #fff3cd; padding: 10px; border-left: 5px solid #ffc107; margin-bottom: 20px; border-radius: 5px; font-size: 14px; }
    #auth-overlay, #awaiting-approval { position: fixed; inset: 0; background: var(--bg); z-index: 999; display: none; align-items: center; justify-content: center; padding: 20px; }
    #auth-box { width: 100%; max-width: 420px; background: var(--card); border: 1px solid #ddd; border-radius: 12px; padding: 0; box-shadow: 0 8px 20px rgba(0,0,0,0.06); }
    #auth-header { padding: 14px 16px; border-bottom:1px solid #eee; font-weight:700; display:flex; gap:8px; align-items:center; }
    #auth-header::before { content:"üîê"; }
    .tabs { display:flex; gap:0; border-bottom:1px solid #eee; }
    .tab { flex:1; padding:10px 12px; background:#fafafa; border:none; border-right:1px solid #eee; cursor:pointer; font-weight:600; }
    .tab:last-child { border-right:none; }
    .tab.active { background:#fff; color:#000; border-bottom:2px solid var(--brand); }
    .pane { padding: 14px 16px; }
    .muted { color: var(--muted); font-size: 13px; }
    .row { display:flex; gap:8px; }
    .row > * { flex:1; }

    #status { margin-top: 10px; font-size: 14px; font-style: italic; }
    button { cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed; }

    .userbar{ background:#eef6ff; border:1px solid #cfe3ff; color:#0b3d91; padding:8px 12px; border-radius:8px; margin:8px 0 12px; display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:14px; }
    .userbar .pill{ background:#fff; border:1px solid #cfe3ff; padding:2px 8px; border-radius:999px; font-size:12px; color:#1b3c6b; }
    .link-pill{ display:inline-block; padding:8px 12px; border:1px solid #cfe3ff; border-radius:8px; background:#eef6ff; color:#0b3c6b; text-decoration:none; position: relative; }

    /* üì± Contatore messaggi */
    .chat-counter {
      position: absolute; top: -8px; right: -8px;
      background-color: #f44336; color: #fff; border-radius: 50%;
      width: 20px; height: 20px; min-width:20px;
      display:flex; align-items:center; justify-content:center;
      font-size:11px; font-weight:bold; border:2px solid #fff; box-shadow:0 2px 4px rgba(0,0,0,.2);
    }
    .chat-counter.hidden { display:none; }
    @keyframes bounce { 0%,20%,60%,100%{transform:translateY(0)} 40%{transform:translateY(-10px)} 80%{transform:translateY(-5px)} }
    .chat-counter.new-message { animation: bounce 1s ease-in-out; }

    /* üêõ Toast popup */
    .toast-container { position: fixed; top: 20px; right: 20px; z-index: 10000; max-width: 320px; }
    .toast {
      background:#fff; border:1px solid #e0e0e0; border-radius:12px;
      box-shadow:0 8px 24px rgba(0,0,0,.15);
      padding:16px; margin-bottom:12px;
      transform:translateX(100%); transition:all .3s cubic-bezier(.4,0,.2,1);
      cursor:pointer; position:relative; overflow:hidden;
    }
    .toast.show { transform:translateX(0); }
    .toast.hide { transform:translateX(100%); opacity:0; }
    .toast::before { content:""; position:absolute; top:0; left:0; width:4px; height:100%; background:var(--brand); }
    .toast-header { display:flex; align-items:center; gap:8px; margin-bottom:8px; font-weight:600; font-size:14px; color:var(--brand); }
    .toast-body { color:#333; font-size:14px; line-height:1.4; margin-left:24px; }
    .toast-close {
      position:absolute; top:8px; right:8px; width:24px; height:24px;
      background:none; border:none; font-size:18px; color:#999; cursor:pointer;
      display:flex; align-items:center; justify-content:center; border-radius:50%;
      transition: background-color .2s;
    }
    .toast-close:hover { background-color:#f0f0f0; }

    /* Stili per campo indirizzo e toggle */
    .address-note {
      font-size: 12px; 
      color: #666; 
      margin-top: 4px; 
      margin-bottom: 8px; 
      display: flex; 
      align-items: center; 
      flex-wrap: wrap;
      gap: 8px;
    }
    .toggle-btn {
      padding: 3px 8px; 
      font-size: 11px; 
      background: #e9ecef; 
      border: 1px solid #adb5bd; 
      border-radius: 4px; 
      cursor: pointer;
      white-space: nowrap;
    }
    .toggle-btn:hover {
      background: #dee2e6;
    }

    /* üîß Stili per validazione campi */
    .field-valid { border-color: #28a745 !important; background-color: #f8fff9 !important; }
    .field-invalid { border-color: #dc3545 !important; background-color: #fff8f8 !important; }
    .field-help { font-size: 12px; margin-top: 2px; margin-bottom: 6px; }
    .field-help.error { color: #dc3545; }
    .field-help.success { color: #28a745; }
  </style>
</head>
<body>

  <!-- OVERLAY AUTH -->
  <div id="auth-overlay">
    <div id="auth-box">
      <div id="auth-header">Accesso</div>

      <div class="tabs">
        <button id="tab-login" class="tab active">Accedi</button>
        <button id="tab-register" class="tab">Registrati</button>
      </div>

      <div id="pane-login" class="pane">
        <input id="log-email" placeholder="Email">
        <input id="log-password" placeholder="Password" type="password">
        <button id="btn-login">Accedi</button>
      </div>

      <div id="pane-register" class="pane" style="display:none;">
        <input id="reg-name" placeholder="Nome (Es: Mario Rossi)" required maxlength="50">
        <div id="name-help" class="field-help">Il nome √® obbligatorio e sar√† visibile all'amministratore</div>
        
        <input id="reg-email" placeholder="Email" required>
        <div id="email-help" class="field-help"></div>
        
        <input id="reg-password" placeholder="Password (min 6 caratteri)" type="password" required>
        <div id="password-help" class="field-help"></div>
        
        <button id="btn-register">Crea account</button>
        <div class="muted" style="margin-top:8px;">Dopo la registrazione l'account deve essere approvato dall'amministratore.</div>
      </div>
    </div>
  </div>

  <!-- ATTESA APPROVAZIONE / BLOCCO ADMIN -->
  <div id="awaiting-approval" class="avviso" style="display:none; flex-direction:column; gap:8px; align-items:center; text-align:center;">
    <h3 style="margin:0;">‚è≥ Account in attesa di approvazione</h3>
    <div>Sei registrato ma non ancora approvato. Quando l'amministratore ti abilita, questa pagina si aggiorner√† automaticamente.</div>
    <button id="btn-logout-while-waiting" style="margin-top:6px; max-width:200px;">Esci</button>
  </div>

  <!-- MODAL RUBRICA -->
  <div id="rubrica-overlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:999; display:none; align-items:center; justify-content:center; padding:20px;">
    <div style="width:100%; max-width:500px; background:white; border-radius:12px; max-height:80vh; overflow:hidden; display:flex; flex-direction:column;">
      <div style="padding:16px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
        <h3 style="margin:0;">üìû Rubrica Aziendale</h3>
        <button id="close-rubrica" style="background:none; border:none; font-size:18px; cursor:pointer; padding:4px;">‚úñ</button>
      </div>
      <div style="padding:16px; flex:1; overflow:auto;">
        <input id="cerca-rubrica" placeholder="Cerca nella rubrica..." style="width:100%; margin-bottom:16px; box-sizing:border-box;">
        <div id="rubrica-container"></div>
      </div>
    </div>
  </div>

  <!-- APP -->
  <div id="app-wrapper" style="display:none;">
    <h1>Archivio Clienti - Trasporti</h1>
    <div id="userbar" class="userbar"></div>

    <!-- üì± Attivazione push (solo se necessario) -->
    <div id="push-activation-wrapper" style="display:none; margin-bottom:12px;">
      <button id="btn-enable-push" style="background-color:#ffdb58; border:1px solid #dcae1d; color:#1b3c6b; padding:6px 12px; border-radius:8px; font-size:14px;">üì± Attiva notifiche push</button>
    </div>

    <div class="avviso">
      ‚ö†Ô∏è <strong>Attenzione:</strong> Questa app contiene dati riservati dei clienti ed √® destinata esclusivamente all'uso operativo da parte di trasportatori autorizzati.
    </div>

    <div class="row" style="align-items:center;">
      <a class="link-pill" href="chat.html" id="chat-link">
        üí¨ Chat con Admin
        <span class="chat-counter hidden" id="chat-counter">0</span>
      </a>
      <button id="btn-rubrica" class="link-pill" style="border:none; cursor:pointer;">
        üìû Rubrica agenti
      </button>
      <button id="btn-logout" style="max-width:160px;">Esci</button>
    </div>

    <!-- FORM INSERIMENTO CLIENTI CON CAMPO INDIRIZZO MIGLIORATO -->
    <div>
      <input id="nome" placeholder="Nome cliente">
      
      <!-- Campo indirizzo NON editabile con toggle -->
      <input id="indirizzo" 
             placeholder="Clicca 'Usa la mia posizione attuale' per compilare automaticamente" 
             readonly
             style="background-color: #f8f9fa; color: #6c757d; cursor: not-allowed;">
      
      <div class="address-note">
        üí° L'indirizzo viene compilato automaticamente quando usi la geolocalizzazione
        <button id="btn-manual-address" type="button" class="toggle-btn">
          Inserimento manuale
        </button>
      </div>
      
      <input id="coordinate" placeholder="Coordinate (es: 44.8015, 10.3274)">
      <button id="btn-gps" type="button">üìç Usa la mia posizione attuale</button>
      
      <textarea id="note" placeholder="Note per la consegna"></textarea>
      <button id="btn-aggiungi">Aggiungi cliente</button>
      <button id="btn-annulla" style="display:none; background-color: #eee;">Annulla modifica</button>
    </div>

    <div><input id="cerca" placeholder="Cerca cliente"></div>
    <div id="clienti"></div>

    <hr>
    <h2>üì° Tracciamento automatico</h2>
    <button id="btn-tracciamento" onclick="avviaTracciamento()">‚ñ∂Ô∏è Attiva tracciamento automatico</button>
    <div id="status"></div>
  </div>

  <!-- üêõ Container per toast messaggi -->
  <div id="toast-container" class="toast-container"></div>

  <!-- APP LOGIC -->
  <script type="module">
    const firebaseConfig = {
      apiKey: "AIzaSyBbjK5sgQ70-p8jODaK_PnLIzPxgfrqQ34",
      authDomain: "archivio-clienti-trasporti.firebaseapp.com",
      projectId: "archivio-clienti-trasporti",
      storageBucket: "archivio-clienti-trasporti.firebasestorage.app",
      messagingSenderId: "773533170263",
      appId: "1:773533170263:web:d05e2b00e991b0294c0112"
    };

    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import {
      getFirestore, collection, addDoc, deleteDoc, doc, setDoc, updateDoc,
      onSnapshot, query, getDocs, getDoc, orderBy, serverTimestamp, limit
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
    import {
      getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword,
      onAuthStateChanged, signOut, updateProfile
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-messaging.js";
    import { arrayUnion } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);
    const auth = getAuth(app);

    const ADMIN_UID = "0dCvHDcVp1PHuWVNIN9i6ZvEVBt2";
    const clientiRef = collection(db, "clienti");

    let nomeUtente = "";
    let clienteDaModificare = null;

    // üì± Chat counter
    let chatUnsub = null;
    let currentUserId = null;
    let lastMessageCount = 0;

    // Variabili rubrica
    let clientiUnsub = null;
    let rubricaUnsub = null;

    // üêõ Toast
    function createToast(title, message, onClick) {
      const container = document.getElementById('toast-container');
      if (!container) return;
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.innerHTML = `
        <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
        <div class="toast-header"><span>üí¨</span>${title}</div>
        <div class="toast-body">${message}</div>
      `;
      if (onClick) {
        toast.addEventListener('click', (e) => {
          if (e.target.classList.contains('toast-close')) return;
          onClick(); hideToast(toast);
        });
      }
      container.appendChild(toast);
      setTimeout(() => toast.classList.add('show'), 100);
      setTimeout(() => hideToast(toast), 6000);
      return toast;
    }
    function hideToast(toast){ toast.classList.add('hide'); setTimeout(()=>{ if(toast.parentElement) toast.remove(); },300); }
    function showMessageToast(senderName, messageText){
      const truncated = messageText.length>80 ? messageText.substring(0,80)+'‚Ä¶' : messageText;
      createToast(`Nuovo messaggio da ${senderName}`, truncated, ()=>{ window.location.href='chat.html'; });
    }

    function startClientiListener(){
      if (clientiUnsub) return;
      const q = query(clientiRef);
      clientiUnsub = onSnapshot(q, mostraClienti, (err)=>console.error(err));
    }
    function stopClientiListener(){ if (clientiUnsub){ clientiUnsub(); clientiUnsub=null; } }

    // ========== RUBRICA ==========
    function startRubricaListener(){
      if (rubricaUnsub) return;
      const qRubrica = query(collection(db, "rubrica"), orderBy("nome", "asc"));
      rubricaUnsub = onSnapshot(qRubrica, mostraRubrica, (err)=>console.error("Errore rubrica:", err));
    }
    function stopRubricaListener(){ if (rubricaUnsub){ rubricaUnsub(); rubricaUnsub=null; } }

    function mostraRubrica(snapshot) {
      const container = el("rubrica-container");
      container.innerHTML = "";
      if (snapshot.empty) {
        container.innerHTML = "<div class='muted'>Nessun contatto in rubrica.</div>";
        return;
      }
      snapshot.forEach(docSnap => {
        const contact = docSnap.data();
        const card = document.createElement("div");
        card.className = "cliente";
        card.innerHTML = `
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
            <strong>${contact.nome || "(senza nome)"}</strong>
          </div>
          ${contact.telefono ? `üìû <a href="tel:${contact.telefono}">${contact.telefono}</a>` : ""}
          ${contact.telefono && contact.email ? " ‚Ä¢ " : ""}
          ${contact.email ? `üìß <a href="mailto:${contact.email}">${contact.email}</a>` : ""}
          ${contact.note ? `<br><em style="color:#666; font-size:13px; margin-top:6px; display:block;">${contact.note}</em>` : ""}
        `;
        container.appendChild(card);
      });
    }

    function filtraRubrica() {
      const queryTxt = el("cerca-rubrica").value.toLowerCase();
      document.querySelectorAll("#rubrica-container .cliente").forEach(c=>{
        const text = c.innerText.toLowerCase();
        c.style.display = text.includes(queryTxt) ? "block" : "none";
      });
    }

    // üì± Chat unread counter
    function startChatListener(userId){
      if (chatUnsub) return;
      const threadMessagesRef = collection(db, "threads", userId, "messages");
      const q = query(threadMessagesRef, orderBy("createdAt","desc"), limit(50));
      chatUnsub = onSnapshot(q, (snapshot)=>{
        let unreadCount=0; let latestUnreadMessage=null; const now=Date.now();
        snapshot.forEach(doc=>{
          const msg = doc.data();
          if (msg.sender !== userId){
            const readBy = Array.isArray(msg.readBy) ? msg.readBy : [];
            if (!readBy.includes(userId)){
              unreadCount++;
              if (!latestUnreadMessage){
                const t = msg.createdAt?.toDate?.()?.getTime() || 0;
                if (now - t < 30000) latestUnreadMessage = msg;
              }
            }
          }
        });
        if (latestUnreadMessage && lastMessageCount < unreadCount && lastMessageCount > 0){
          if (!document.hidden && document.hasFocus()){
            showMessageToast('Admin', latestUnreadMessage.text || 'Nuovo messaggio');
          }
        }
        lastMessageCount = unreadCount;
        updateChatCounter(unreadCount);
        console.log(`üì± Messaggi non letti: ${unreadCount}`);
      }, (err)=>console.error("Errore listener chat:", err));
    }
    function stopChatListener(){ if (chatUnsub){ chatUnsub(); chatUnsub=null; lastMessageCount=0; } }
    function updateChatCounter(count){
      const counter = document.getElementById('chat-counter');
      if (count>0){
        counter.textContent = count>99 ? '99+' : count;
        counter.classList.remove('hidden');
        counter.classList.add('new-message'); setTimeout(()=>counter.classList.remove('new-message'),1000);
        document.title = `(${count}) Archivio Clienti - Trasporti`;
      } else {
        counter.classList.add('hidden'); document.title='Archivio Clienti - Trasporti';
      }
    }

    // segna letti quando si apre la chat
    document.getElementById('chat-link').addEventListener('click', async ()=>{
      if (!currentUserId) return;
      try{
        const threadMessagesRef = collection(db, "threads", currentUserId, "messages");
        const q = query(threadMessagesRef);
        const snapshot = await getDocs(q);
        const batch = [];
        snapshot.forEach((d)=>{
          const msg = d.data();
          if (msg.sender !== currentUserId){
            const readBy = Array.isArray(msg.readBy) ? msg.readBy : [];
            if (!readBy.includes(currentUserId)){
              batch.push(updateDoc(d.ref, { readBy: arrayUnion(currentUserId) }));
            }
          }
        });
        if (batch.length>0){ await Promise.all(batch); console.log('‚úÖ Messaggi segnati come letti'); }
      }catch(e){ console.error('Errore nel segnare messaggi come letti:', e); }
    });

    let userUnsub = null;
    const el = (id)=>document.getElementById(id);
    const show = (node)=>{ node.style.display = (node.id==='auth-overlay' || node.id==='awaiting-approval') ? 'flex' : 'block'; };
    const hide = (node)=> node.style.display = 'none';
    function enableAppUI(){ show(el("app-wrapper")); hide(el("auth-overlay")); hide(el("awaiting-approval")); }
    function disableAppUI(){ hide(el("app-wrapper")); }
    function authErrorMsg(e){
      switch(e?.code){
        case 'auth/weak-password': return 'La password deve avere almeno 6 caratteri.';
        case 'auth/email-already-in-use': return 'Questa email √® gi√† registrata. Prova ad accedere.';
        case 'auth/invalid-email': return 'Email non valida.';
        case 'auth/invalid-credential': return 'Credenziali non valide.';
        case 'auth/network-request-failed': return 'Problema di rete. Controlla la connessione.';
        default: return e?.message || 'Errore imprevisto.';
      }
    }
    const disableBtn = (btn,on)=> btn.disabled=!!on;

    function renderUserBar(uAuth,uData){
      const box = document.getElementById("userbar"); if(!box) return;
      const name  = (uData?.name || uAuth?.displayName || (uAuth?.email ? uAuth.email.split("@")[0] : "")).trim();
      const email = uAuth?.email || "";
      const role  = (uData?.role) || (uAuth?.uid === ADMIN_UID ? "admin" : "driver");
      box.innerHTML = `üë§ <strong>${name || "(senza nome)"}</strong>
                       <span class="pill">${email}</span>
                       <span class="pill">${role}</span>`;
    }

    const tabLogin = el("tab-login");
    const tabRegister = el("tab-register");
    const paneLogin = el("pane-login");
    const paneRegister = el("pane-register");
    const authHeader = el("auth-header");
    function switchAuth(mode){
      if (mode==="login"){ paneLogin.style.display="block"; paneRegister.style.display="none"; tabLogin.classList.add("active"); tabRegister.classList.remove("active"); authHeader.textContent="Accesso"; }
      else { paneLogin.style.display="none"; paneRegister.style.display="block"; tabRegister.classList.add("active"); tabLogin.classList.remove("active"); authHeader.textContent="Registrazione"; }
    }
    tabLogin.addEventListener("click", ()=>switchAuth("login"));
    tabRegister.addEventListener("click", ()=>switchAuth("register"));
    function showAuth(defaultTab="login"){ disableAppUI(); show(el("auth-overlay")); switchAuth(defaultTab); }

    // üîß Validazione in tempo reale per i campi di registrazione
    function validateName(value) {
      if (!value || value.length === 0) {
        return { valid: false, message: "Il nome √® obbligatorio" };
      }
      if (value.length < 2) {
        return { valid: false, message: "Il nome deve avere almeno 2 caratteri" };
      }
      if (value.length > 50) {
        return { valid: false, message: "Il nome √® troppo lungo (massimo 50 caratteri)" };
      }
      return { valid: true, message: "Nome valido ‚úì" };
    }

    function validateEmail(value) {
      if (!value || value.length === 0) {
        return { valid: false, message: "L'email √® obbligatoria" };
      }
      if (!value.includes('@') || !value.includes('.')) {
        return { valid: false, message: "Inserisci un'email valida" };
      }
      return { valid: true, message: "Email valida ‚úì" };
    }

    function validatePassword(value) {
      if (!value || value.length === 0) {
        return { valid: false, message: "La password √® obbligatoria" };
      }
      if (value.length < 6) {
        return { valid: false, message: "La password deve avere almeno 6 caratteri" };
      }
      return { valid: true, message: "Password valida ‚úì" };
    }

    function updateFieldStatus(fieldId, helpId, validation) {
      const field = el(fieldId);
      const help = el(helpId);
      
      if (validation.valid) {
        field.className = field.className.replace(' field-invalid', '') + ' field-valid';
        help.className = 'field-help success';
        help.textContent = validation.message;
      } else {
        field.className = field.className.replace(' field-valid', '') + ' field-invalid';
        help.className = 'field-help error';
        help.textContent = validation.message;
      }
    }

    // Aggiungi validazione in tempo reale
    el("reg-name").addEventListener("input", function() {
      const validation = validateName(this.value.trim());
      updateFieldStatus("reg-name", "name-help", validation);
    });

    el("reg-email").addEventListener("input", function() {
      const validation = validateEmail(this.value.trim());
      updateFieldStatus("reg-email", "email-help", validation);
    });

    el("reg-password").addEventListener("input", function() {
      const validation = validatePassword(this.value);
      updateFieldStatus("reg-password", "password-help", validation);
    });

    // üîß REGISTRAZIONE - VERSIONE MIGLIORATA
    el("btn-register").addEventListener("click", async ()=>{
      const name = el("reg-name").value.trim();
      const email = el("reg-email").value.trim();
      const password = el("reg-password").value;
      
      console.log("üöÄ Tentativo registrazione:", { name, email });
      
      // Validazione completa
      const nameValidation = validateName(name);
      const emailValidation = validateEmail(email);
      const passwordValidation = validatePassword(password);
      
      updateFieldStatus("reg-name", "name-help", nameValidation);
      updateFieldStatus("reg-email", "email-help", emailValidation);
      updateFieldStatus("reg-password", "password-help", passwordValidation);
      
      if (!nameValidation.valid) {
        el("reg-name").focus();
        return;
      }
      if (!emailValidation.valid) {
        el("reg-email").focus();
        return;
      }
      if (!passwordValidation.valid) {
        el("reg-password").focus();
        return;
      }
      
      disableBtn(el("btn-register"), true);
      el("btn-register").textContent = "Registrazione in corso...";
      
      try{
        console.log("üî• Inizio registrazione per:", { name, email });
        
        // 1. Crea account Firebase Auth
        const cred = await createUserWithEmailAndPassword(auth, email, password);
        console.log("‚úÖ Account Firebase Auth creato:", cred.user.uid);
        
        // 2. Aggiorna il profilo Firebase Auth con il nome
        await updateProfile(cred.user, { displayName: name });
        console.log("‚úÖ DisplayName aggiornato in Firebase Auth");
        
        // 3. Salva i dati in Firestore (con retry in caso di errore)
        const userData = {
          name: name,
          email: email,
          role: "driver",
          approved: false,
          createdAt: serverTimestamp()
        };
        
        console.log("üíæ Salvataggio dati utente in Firestore:", userData);
        
        let saveSuccess = false;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (!saveSuccess && retryCount < maxRetries) {
          try {
            await setDoc(doc(db, "users", cred.user.uid), userData);
            console.log("‚úÖ Dati utente salvati in Firestore al tentativo", retryCount + 1);
            saveSuccess = true;
          } catch (saveError) {
            retryCount++;
            console.warn(`‚ö†Ô∏è Tentativo ${retryCount} fallito:`, saveError);
            
            if (retryCount >= maxRetries) {
              throw new Error(`Impossibile salvare i dati dopo ${maxRetries} tentativi: ${saveError.message}`);
            }
            
            // Aspetta un po' prima di riprovare
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
        
        // 4. Messaggio di successo
        alert(`Registrazione completata con successo!\n\nNome: ${name}\nEmail: ${email}\n\nIl tuo account √® ora in attesa di approvazione da parte dell'amministratore.`);
        
        // 5. Pulisci i campi
        el("reg-name").value = "";
        el("reg-email").value = "";
        el("reg-password").value = "";
        
        // Resetta lo styling dei campi
        el("reg-name").className = el("reg-name").className.replace(/field-(valid|invalid)/g, '');
        el("reg-email").className = el("reg-email").className.replace(/field-(valid|invalid)/g, '');
        el("reg-password").className = el("reg-password").className.replace(/field-(valid|invalid)/g, '');
        
        // Resetta i messaggi di aiuto
        el("name-help").className = "field-help";
        el("name-help").textContent = "Il nome √® obbligatorio e sar√† visibile all'amministratore";
        el("email-help").className = "field-help";
        el("email-help").textContent = "";
        el("password-help").className = "field-help";
        el("password-help").textContent = "";
        
        console.log("üéâ Registrazione completata con successo per:", name);
        
      } catch(e) { 
        console.error("‚ùå Errore durante la registrazione:", e);
        
        let errorMessage = "Registrazione non riuscita: ";
        
        // Messaggi di errore pi√π specifici
        if (e.message && e.message.includes("salvare i dati")) {
          errorMessage += "Problema nel salvataggio dei dati. Verifica la connessione e riprova.";
        } else {
          errorMessage += authErrorMsg(e);
        }
        
        alert(errorMessage);
      } finally { 
        disableBtn(el("btn-register"), false);
        el("btn-register").textContent = "Crea account";
      }
    });

    // LOGIN
    el("btn-login").addEventListener("click", async ()=>{
      const email = el("log-email").value.trim();
      const password = el("log-password").value;
      if (!email || !password){ alert("Inserisci email e password."); return; }
      disableBtn(el("btn-login"), true);
      try{ await signInWithEmailAndPassword(auth, email, password); }
      catch(e){ alert("Accesso non riuscito: " + authErrorMsg(e)); }
      finally{ disableBtn(el("btn-login"), false); }
    });

    // LOGOUT
    el("btn-logout").addEventListener("click", ()=>signOut(auth));
    el("btn-logout-while-waiting").addEventListener("click", ()=>signOut(auth));

    // üì± PUSH (FCM)
    const messaging = getMessaging(app);
    const VAPID_PUBLIC_KEY = "BG1pU9CLPvIoAwBKbUFtveLXiX8EgSqzUyuoVl465d5zuSzyQZN043nfnN1xamZuDa9gZZEbsNpT-Vs_m_x-nS0";

    async function enablePushForUser(user){
      try{
        if (!('Notification' in window) || !('serviceWorker' in navigator)) return;

        // Usa il Service Worker GI√Ä registrato globalmente (vedi blocco a fondo pagina)
        const reg = await navigator.serviceWorker.ready;

        const perm = await Notification.requestPermission();
        if (perm!=='granted'){ console.warn('Permesso notifiche negato'); return; }

        const token = await getToken(messaging, {
          vapidKey: VAPID_PUBLIC_KEY,
          serviceWorkerRegistration: reg
        });
        if (!token){ console.warn('Nessun token FCM ricevuto'); return; }

        await setDoc(doc(db,"users",user.uid), { fcmTokens: { [token]: true } }, { merge:true });
        console.log('‚úÖ FCM token salvato per', user.uid);
      }catch(e){ console.warn('Errore enablePushForUser', e); }
    }

    async function handlePushPermission(user){
      if (!('Notification' in window) || !('serviceWorker' in navigator)) return;
      const wrapper = document.getElementById('push-activation-wrapper');
      const btn = document.getElementById('btn-enable-push');
      if (Notification.permission==='granted'){
        if (wrapper) wrapper.style.display='none';
        await enablePushForUser(user);
      } else {
        if (wrapper) wrapper.style.display='block';
        if (btn){
          btn.onclick = async ()=>{
            btn.disabled = true;
            try{ await enablePushForUser(user); }
            finally{ if (wrapper) wrapper.style.display='none'; btn.disabled=false; }
          };
        }
      }
    }

    onMessage(messaging, (payload)=>{
      console.log('üì® Push in foreground:', payload);
      if (payload.notification){
        const title = payload.notification.title || 'Nuovo messaggio';
        const body  = payload.notification.body  || '';
        createToast(title, body, ()=>{ window.location.href='chat.html'; });
      }
    });

    onAuthStateChanged(auth, async (user)=>{
      if (!user){
        showAuth("login");
        stopClientiListener(); stopRubricaListener(); stopChatListener(); currentUserId=null; updateChatCounter(0);
        if (userUnsub){ userUnsub(); userUnsub=null; }
        const ub = document.getElementById("userbar"); if (ub) ub.innerHTML="";
        return;
      }
      currentUserId = user.uid;

      const uref = doc(db,"users",user.uid);
      const snap = await getDoc(uref);
      if (!snap.exists()){
        await setDoc(uref, {
          name: user.displayName || "", email: user.email,
          role: (user.uid===ADMIN_UID) ? "admin":"driver",
          approved: (user.uid===ADMIN_UID) ? true:false, createdAt: serverTimestamp()
        }, { merge:true });
      } else {
        const dataNow = snap.data() || {};
        if (!("role" in dataNow)){ await updateDoc(uref, { role: (user.uid===ADMIN_UID) ? "admin" : "driver" }); }
        await setDoc(uref, {
          name: dataNow.name || user.displayName || "", email: dataNow.email || user.email || ""
        }, { merge:true });
      }

      if (userUnsub){ userUnsub(); userUnsub=null; }
      userUnsub = onSnapshot(uref, (usnap)=>{
        const data = usnap.data() || {};
        nomeUtente = (data.name || (user.email ? user.email.split("@")[0] : "")).trim();
        renderUserBar(user, data);

        if (data.role==="driver" && data.approved===true){
          enableAppUI(); startClientiListener(); startRubricaListener(); startChatListener(user.uid); handlePushPermission(user);
        } else if (data.role==="admin"){
          disableAppUI(); hide(el("auth-overlay")); show(el("awaiting-approval"));
          el("awaiting-approval").innerHTML =
            "<h3>üëë Sei loggato come admin</h3><div>L'app operativa √® solo per gli autisti approvati. Vai su <a href='admin.html'>admin.html</a>.</div><button id='btn-logout-while-waiting' style='margin-top:6px; max-width:200px;'>Esci</button>";
          document.getElementById('btn-logout-while-waiting').onclick = ()=>signOut(auth);
          stopClientiListener(); stopRubricaListener(); stopChatListener(); handlePushPermission(user);
        } else {
          disableAppUI(); hide(el("auth-overlay")); show(el("awaiting-approval"));
          const nomeUtentePendente = data.name || user.displayName || user.email?.split("@")[0] || "Utente";
          el("awaiting-approval").innerHTML = `
            <h3 style="margin:0;">‚è≥ Account in attesa di approvazione</h3>
            <div>Ciao <strong>${nomeUtentePendente}</strong>! Sei registrato ma non ancora approvato. Quando l'amministratore ti abiliter√†, questa pagina si aggiorner√† automaticamente.</div>
            <button id="btn-logout-while-waiting" style="margin-top:6px; max-width:200px;">Esci</button>
          `;
          document.getElementById('btn-logout-while-waiting').onclick = ()=>signOut(auth);
          stopClientiListener(); stopRubricaListener(); stopChatListener();
        }
      });
    });

    // ‚úÖ Aggiungi/Modifica/Elimina clienti
    async function aggiungiOmodificaCliente() {
      const nome = el("nome").value.trim();
      const indirizzo = el("indirizzo").value.trim();
      const coordinate = el("coordinate").value.trim();
      const note = el("note").value.trim();
      if (!nome || !indirizzo) { alert("Inserisci almeno nome e indirizzo."); return; }

      const user = auth.currentUser;
      const autore = {
        uid: user?.uid || null,
        name: (nomeUtente || user?.displayName || (user?.email ? user.email.split("@")[0] : "")) || "",
        email: user?.email || ""
      };

      const payload = { nome, indirizzo, coordinate, note };

      if (clienteDaModificare) {
        const docRef = doc(db, "clienti", clienteDaModificare);
        try {
          await updateDoc(docRef, payload);
          clienteDaModificare = null;
          el("btn-aggiungi").innerText = "Aggiungi cliente";
          el("btn-annulla").style.display = "none";
        } catch (error) {
          alert("Impossibile salvare le modifiche: il cliente non esiste pi√π.");
          console.error(error);
        }
      } else {
        await addDoc(clientiRef, {
          ...payload,
          createdAt: serverTimestamp(),
          createdBy: autore
        });
      }

      el("nome").value=""; el("indirizzo").value=""; el("coordinate").value=""; el("note").value="";
    }

    async function eliminaCliente(id) {
      if (confirm("Sei sicuro di voler eliminare questo cliente?")) {
        await deleteDoc(doc(db, "clienti", id));
      }
    }

    function preparaModificaCliente(id, cliente) {
      el("nome").value = cliente.nome; el("indirizzo").value = cliente.indirizzo;
      el("coordinate").value = cliente.coordinate || ""; el("note").value = cliente.note || "";
      clienteDaModificare = id; el("btn-aggiungi").innerText = "Salva modifiche"; el("btn-annulla").style.display = "inline-block";
      
      // Temporaneamente abilita il campo indirizzo per la modifica
      const indirizzoField = el("indirizzo");
      const toggleBtn = el("btn-manual-address");
      indirizzoField.readOnly = false;
      indirizzoField.style.backgroundColor = '#fff';
      indirizzoField.style.color = '#000';
      indirizzoField.style.cursor = 'text';
      toggleBtn.textContent = 'Blocca modifica';
      toggleBtn.style.backgroundColor = '#fff3cd';
    }

    function annullaModifica() {
      clienteDaModificare = null;
      el("nome").value = ""; el("indirizzo").value = ""; el("coordinate").value = ""; el("note").value = "";
      el("btn-aggiungi").innerText = "Aggiungi cliente"; el("btn-annulla").style.display = "none";
      
      // Ripristina il campo indirizzo come readonly
      const indirizzoField = el("indirizzo");
      const toggleBtn = el("btn-manual-address");
      indirizzoField.readOnly = true;
      indirizzoField.style.backgroundColor = '#f8f9fa';
      indirizzoField.style.color = '#6c757d';
      indirizzoField.style.cursor = 'not-allowed';
      indirizzoField.placeholder = "Clicca 'Usa la mia posizione attuale' per compilare automaticamente";
      toggleBtn.textContent = 'Inserimento manuale';
      toggleBtn.style.backgroundColor = '#e9ecef';
    }

    function mostraClienti(snapshot) {
      const clientiDiv = el("clienti"); clientiDiv.innerHTML = "";
      snapshot.forEach(docSnap => {
        const c = docSnap.data();
        const div = document.createElement("div");
        div.className = "cliente";
        const inseritoDa = c.createdBy ? `<div class="muted">Inserito da: <strong>${c.createdBy.name || "sconosciuto"}</strong>${c.createdAt?.toDate ? " ‚Ä¢ " + c.createdAt.toDate().toLocaleString() : ""}</div>` : "";
        div.innerHTML = `<strong>${c.nome || "(senza nome)"}</strong><br>
                         ${c.indirizzo || ""}<br>
                         ${c.coordinate ? `<a href='https://maps.google.com/?q=${c.coordinate}' target='_blank'>Vai a Google Maps</a><br>` : ""}
                         ${c.note ? `<em>${c.note}</em><br>` : ""}
                         ${inseritoDa}
                         <button class='btn-azione' onclick='eliminaCliente("${docSnap.id}")'>üóëÔ∏è Elimina</button>
                         <button class='btn-azione' onclick='preparaModificaCliente("${docSnap.id}", ${JSON.stringify(c).replace(/"/g, '&quot;')})'>‚úèÔ∏è Modifica</button>`;
        clientiDiv.appendChild(div);
      });
    }

    function filtraClienti() {
      const queryTxt = el("cerca").value.toLowerCase();
      document.querySelectorAll(".cliente").forEach(c=>{
        c.style.display = c.innerText.toLowerCase().includes(queryTxt) ? "block" : "none";
      });
    }

    el("btn-aggiungi").addEventListener("click", aggiungiOmodificaCliente);
    el("btn-annulla").addEventListener("click", annullaModifica);
    el("cerca").addEventListener("input", filtraClienti);
    el("cerca-rubrica").addEventListener("input", filtraRubrica);

    // Modal rubrica
    el("btn-rubrica").addEventListener("click", () => {
      el("rubrica-overlay").style.display = "flex";
      el("cerca-rubrica").value = "";
      filtraRubrica();
    });
    el("close-rubrica").addEventListener("click", () => { el("rubrica-overlay").style.display = "none"; });
    el("rubrica-overlay").addEventListener("click", (e) => { if (e.target === el("rubrica-overlay")) el("rubrica-overlay").style.display = "none"; });

    // üìç GPS CON REVERSE GEOCODING E COMPILAZIONE AUTOMATICA INDIRIZZO
    el("btn-gps").addEventListener("click", async () => {
      if (!auth.currentUser) { alert("Devi essere loggato."); return; }
      if (!('geolocation' in navigator)) { alert("Geolocalizzazione non supportata."); return; }

      const mezzoNome = (nomeUtente || auth.currentUser.displayName || (auth.currentUser.email?.split("@")[0] ?? "")).trim() || 'Senza nome';
      const docRef = doc(db, 'posizioniMezzo', auth.currentUser.uid);

      // Mostra indicatore di caricamento
      el("btn-gps").textContent = "üìç Ottenendo posizione...";
      el("btn-gps").disabled = true;

      navigator.geolocation.getCurrentPosition(async position => {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        
        // Compila le coordinate
        el("coordinate").value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        
        // ‚úÖ NUOVO: Ottieni l'indirizzo tramite reverse geocoding
        try {
          el("btn-gps").textContent = "üè† Ottenendo indirizzo...";
          
          // Usa Nominatim (OpenStreetMap) - gratuito e senza API key
          const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`,
            {
              headers: {
                'User-Agent': 'ArchivioClienti-Trasporti/1.0' // Richiesto da Nominatim
              }
            }
          );
          
          if (response.ok) {
            const data = await response.json();
            
            if (data && data.address) {
              const addr = data.address;
              const parts = [];
              
              // Priorit√†: strada e numero civico
              if (addr.house_number && addr.road) {
                parts.push(`${addr.road} ${addr.house_number}`);
              } else if (addr.road) {
                parts.push(addr.road);
              }
              
              // Aggiungi citt√†
              if (addr.city || addr.town || addr.village) {
                parts.push(addr.city || addr.town || addr.village);
              }
              
              // Aggiungi provincia/stato
              if (addr.state || addr.province) {
                parts.push(addr.state || addr.province);
              }
              
              // Aggiungi paese se non √® Italia
              if (addr.country && addr.country !== 'Italia' && addr.country !== 'Italy') {
                parts.push(addr.country);
              }
              
              if (parts.length > 0) {
                el("indirizzo").value = parts.join(', ');
              } else {
                el("indirizzo").value = data.display_name || `Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}`;
              }
            } else {
              // Fallback: se non trova indirizzo specifico, usa le coordinate
              el("indirizzo").value = `Posizione: ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
            }
          } else {
            // Errore API: usa coordinate come fallback
            el("indirizzo").value = `Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}`;
          }
        } catch (error) {
          console.warn("Errore reverse geocoding:", error);
          // Fallback in caso di errore
          el("indirizzo").value = `Coordinate: ${lat.toFixed(4)}, ${lng.toFixed(4)}`;
        }

        // Salva posizione per tracking (come prima)
        try {
          await setDoc(docRef, {
            uid: auth.currentUser.uid,
            mezzo: mezzoNome,
            lat, lng,
            accuracy: position.coords.accuracy,
            online: true,
            updatedAt: serverTimestamp()
          }, { merge: true });
        } catch (error) {
          console.warn("Errore salvataggio posizione:", error);
        }
        
        // Ripristina pulsante
        el("btn-gps").textContent = "üìç Usa la mia posizione attuale";
        el("btn-gps").disabled = false;
        
      }, err => {
        // Errore geolocalizzazione
        alert("Impossibile ottenere la posizione. Assicurati che il GPS sia attivo.");
        console.error(err);
        
        // Ripristina pulsante
        el("btn-gps").textContent = "üìç Usa la mia posizione attuale";
        el("btn-gps").disabled = false;
      }, { 
        enableHighAccuracy: true, 
        maximumAge: 5000, 
        timeout: 15000 
      });
    });

    // TOGGLE PER CAMPO INDIRIZZO
    el("btn-manual-address").addEventListener("click", () => {
      const indirizzoField = el("indirizzo");
      const toggleBtn = el("btn-manual-address");
      
      if (indirizzoField.readOnly) {
        // Abilita modifica manuale
        indirizzoField.readOnly = false;
        indirizzoField.style.backgroundColor = '#fff';
        indirizzoField.style.color = '#000';
        indirizzoField.style.cursor = 'text';
        indirizzoField.placeholder = 'Inserisci indirizzo manualmente';
        toggleBtn.textContent = 'Blocca modifica';
        toggleBtn.style.backgroundColor = '#fff3cd';
        indirizzoField.focus();
      } else {
        // Disabilita modifica manuale
        indirizzoField.readOnly = true;
        indirizzoField.style.backgroundColor = '#f8f9fa';
        indirizzoField.style.color = '#6c757d';
        indirizzoField.style.cursor = 'not-allowed';
        indirizzoField.placeholder = "Clicca 'Usa la mia posizione attuale' per compilare automaticamente";
        toggleBtn.textContent = 'Inserimento manuale';
        toggleBtn.style.backgroundColor = '#e9ecef';
      }
    });

    // üî¥üîµ Tracking
    let watchId = null;

    window.avviaTracciamento = async function () {
      const status = document.getElementById('status');
      const btn = document.getElementById('btn-tracciamento');

      if (!auth.currentUser) { status.textContent = 'Non sei loggato.'; return; }
      if (!('geolocation' in navigator)) { status.textContent = 'Geolocalizzazione non supportata.'; return; }

      if (watchId) { await stopTracking(); status.textContent = 'Tracciamento disattivato.'; btn.textContent = '‚ñ∂Ô∏è Attiva tracciamento automatico'; return; }

      const uid = auth.currentUser.uid;
      const mezzoNome = (nomeUtente || auth.currentUser.displayName || (auth.currentUser.email?.split("@")[0] ?? "")).trim() || 'Senza nome';
      const docRef = doc(db, 'posizioniMezzo', uid);

      await setDoc(docRef, { uid, mezzo: mezzoNome, online:true, updatedAt: serverTimestamp() }, { merge:true });

      status.textContent = 'Attivo: invio posizioni‚Ä¶';
      btn.textContent = '‚è∏Ô∏è Disattiva tracciamento';

      watchId = navigator.geolocation.watchPosition(async pos => {
        const { latitude:lat, longitude:lng, accuracy } = pos.coords;
        await setDoc(docRef, {
          uid, mezzo: mezzoNome, lat, lng, accuracy, online:true, updatedAt: serverTimestamp()
        }, { merge:true });
        status.textContent = `Ultima posizione: ${lat.toFixed(5)}, ${lng.toFixed(5)} (¬±${Math.round(accuracy)} m)`;
      }, async err => {
        status.textContent = 'Errore GPS: ' + err.message;
        await setDoc(docRef, { online:false, updatedAt: serverTimestamp() }, { merge:true });
      }, { enableHighAccuracy:true, maximumAge:5000, timeout:15000 });
    };

    async function stopTracking() {
      const btn = document.getElementById('btn-tracciamento');
      if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; }
      if (auth.currentUser) {
        try {
          await deleteDoc(doc(db, 'posizioniMezzo', auth.currentUser.uid));
        } catch (e) {
          await setDoc(doc(db, 'posizioniMezzo', auth.currentUser.uid), { online:false, updatedAt: serverTimestamp() }, { merge:true });
        }
      }
      if (btn) btn.textContent = '‚ñ∂Ô∏è Attiva tracciamento automatico';
    }

    window.addEventListener('beforeunload', async () => {
      if (watchId && auth.currentUser) {
        try { await deleteDoc(doc(db, 'posizioniMezzo', auth.currentUser.uid)); } catch(e){}
      }
    });

    // Espone funzioni globali per i bottoni inline
    window.eliminaCliente = eliminaCliente;
    window.preparaModificaCliente = preparaModificaCliente;
  </script>

  <!-- üì± Registrazione UNICA del Service Worker con path relativo per Netlify -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./firebase-messaging-sw.js', {
        scope: './'
      })
      .then(() => console.log('‚úÖ SW registrato per Netlify'))
      .catch(err => console.warn('SW registration failed', err));
    }
  </script>
</body>
</html>