<!DOCTYPE html>
<html>
<head>
  <link rel="manifest" href="manifest.json">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Archivio Clienti - Trasporti</title>
  <style>
    :root { --bg:#f9f9f9; --card:#fff; --txt:#222; --muted:#666; --brand:#007bff; }
    body { font-family: Arial, sans-serif; padding: 15px; margin: 0; background-color: var(--bg); color:var(--txt); }
    h1 { font-size: 22px; margin-bottom: 10px; }
    input, textarea, button, select { margin: 6px 0; width: 100%; padding: 10px; font-size: 16px; box-sizing: border-box; }
    textarea { resize: vertical; }
    #clienti { margin-top: 20px; }
    .cliente { border: 1px solid #ddd; padding: 12px; margin-bottom: 12px; border-radius: 8px; background-color: var(--card); }
    .btn-azione { margin-top: 8px; margin-right: 5px; font-size: 14px; padding: 6px 10px; }
    .avviso { background-color: #fff3cd; padding: 10px; border-left: 5px solid #ffc107; margin-bottom: 20px; border-radius: 5px; font-size: 14px; }
    #auth-overlay, #awaiting-approval { position: fixed; inset: 0; background: var(--bg); z-index: 999; display: none; align-items: center; justify-content: center; padding: 20px; }
    #auth-box { width: 100%; max-width: 420px; background: var(--card); border: 1px solid #ddd; border-radius: 12px; padding: 0; box-shadow: 0 8px 20px rgba(0,0,0,0.06); }
    #auth-header { padding: 14px 16px; border-bottom:1px solid #eee; font-weight:700; display:flex; gap:8px; align-items:center; }
    #auth-header::before { content:"üîí"; }
    .tabs { display:flex; gap:0; border-bottom:1px solid #eee; }
    .tab { flex:1; padding:10px 12px; background:#fafafa; border:none; border-right:1px solid #eee; cursor:pointer; font-weight:600; }
    .tab:last-child { border-right:none; }
    .tab.active { background:#fff; color:#000; border-bottom:2px solid var(--brand); }
    .pane { padding: 14px 16px; }
    .muted { color: var(--muted); font-size: 13px; }
    .row { display:flex; gap:8px; }
    .row > * { flex:1; }
    #status { margin-top: 10px; font-size: 14px; font-style: italic; }
    button { cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .userbar{ background:#eef6ff; border:1px solid #cfe3ff; color:#0b3d91; padding:8px 12px; border-radius:8px; margin:8px 0 12px; display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:14px; }
    .userbar .pill{ background:#fff; border:1px solid #cfe3ff; padding:2px 8px; border-radius:999px; font-size:12px; color:#1b3c6b; }
    .link-pill{ display:inline-block; padding:8px 12px; border:1px solid #cfe3ff; border-radius:8px; background:#eef6ff; color:#0b3d91; text-decoration:none; position: relative; }
    
    /* üîî Stili per il contatore messaggi */
    .chat-counter {
      position: absolute;
      top: -8px;
      right: -8px;
      background-color: #f44336;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      min-width: 20px;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .chat-counter.hidden {
      display: none;
    }
    
    /* Animazione per nuovi messaggi */
    @keyframes bounce {
      0%, 20%, 60%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      80% { transform: translateY(-5px); }
    }
    
    .chat-counter.new-message {
      animation: bounce 1s ease-in-out;
    }
    
    /* Toast popup per messaggi */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      max-width: 320px;
    }
    
    .toast {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      padding: 16px;
      margin-bottom: 12px;
      transform: translateX(100%);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .toast.show {
      transform: translateX(0);
    }
    
    .toast.hide {
      transform: translateX(100%);
      opacity: 0;
    }
    
    .toast::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: var(--brand);
    }
    
    .toast-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-weight: 600;
      font-size: 14px;
      color: var(--brand);
    }
    
    .toast-body {
      color: #333;
      font-size: 14px;
      line-height: 1.4;
      margin-left: 24px;
    }
    
    .toast-close {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      font-size: 18px;
      color: #999;
      cursor: pointer;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s;
    }
    
    .toast-close:hover {
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>

  <!-- OVERLAY AUTH -->
  <div id="auth-overlay">
    <div id="auth-box">
      <div id="auth-header">Accesso</div>

      <div class="tabs">
        <button id="tab-login" class="tab active">Accedi</button>
        <button id="tab-register" class="tab">Registrati</button>
      </div>

      <div id="pane-login" class="pane">
        <input id="log-email" placeholder="Email">
        <input id="log-password" placeholder="Password" type="password">
        <button id="btn-login">Accedi</button>
      </div>

      <div id="pane-register" class="pane" style="display:none;">
        <input id="reg-name" placeholder="Nome (Es: Camion Alessio)">
        <input id="reg-email" placeholder="Email">
        <input id="reg-password" placeholder="Password (min 6 caratteri)" type="password">
        <button id="btn-register">Crea account</button>
        <div class="muted" style="margin-top:8px;">Dopo la registrazione l'account deve essere approvato dall'amministratore.</div>
      </div>
    </div>
  </div>

  <!-- ATTESA APPROVAZIONE / BLOCCO ADMIN -->
  <div id="awaiting-approval" class="avviso" style="display:none; flex-direction:column; gap:8px; align-items:center; text-align:center;">
    <h3 style="margin:0;">‚è≥ Account in attesa di approvazione</h3>
    <div>Sei registrato ma non ancora approvato. Quando l'amministratore ti abilita, questa pagina si aggiorner√† automaticamente.</div>
    <button id="btn-logout-while-waiting" style="margin-top:6px; max-width:200px;">Esci</button>
  </div>

  <!-- APP -->
  <div id="app-wrapper" style="display:none;">
    <h1>Archivio Clienti - Trasporti</h1>
    <div id="userbar" class="userbar"></div>

    <!-- üîî Wrapper per pulsante di attivazione delle notifiche push (mostrato solo se necessario) -->
    <div id="push-activation-wrapper" style="display:none; margin-bottom:12px;">
      <button id="btn-enable-push" style="background-color:#ffdb58; border:1px solid #dcae1d; color:#1b3c6b; padding:6px 12px; border-radius:8px; font-size:14px;">üîî Attiva notifiche push</button>
    </div>

    <div class="avviso">
      ‚ö†Ô∏è <strong>Attenzione:</strong> Questa app contiene dati riservati dei clienti ed √® destinata esclusivamente all'uso operativo da parte di trasportatori autorizzati.
    </div>

    <div class="row" style="align-items:center;">
      <!-- üîî Chat con contatore messaggi -->
      <a class="link-pill" href="chat.html" id="chat-link">
        üí¨ Chat con Admin
        <span class="chat-counter hidden" id="chat-counter">0</span>
      </a>
      <button id="btn-logout" style="max-width:160px;">Esci</button>
    </div>

    <div>
      <input id="nome" placeholder="Nome cliente">
      <input id="indirizzo" placeholder="Indirizzo">
      <input id="coordinate" placeholder="Coordinate (es: 44.8015, 10.3274)">
      <button id="btn-gps" type="button">üìç Usa la mia posizione attuale</button>
      <textarea id="note" placeholder="Note per la consegna"></textarea>
      <button id="btn-aggiungi">Aggiungi cliente</button>
      <button id="btn-annulla" style="display:none; background-color: #eee;">Annulla modifica</button>
    </div>

    <div><input id="cerca" placeholder="Cerca cliente"></div>
    <div id="clienti"></div>

    <hr>
    <h2>üì° Tracciamento automatico</h2>
    <button id="btn-tracciamento" onclick="avviaTracciamento()">‚ñ∂Ô∏è Attiva tracciamento automatico</button>
    <div id="status"></div>
  </div>

  <!-- üçû Container per toast messaggi -->
  <div id="toast-container" class="toast-container"></div>

  <script type="module">
// AGGIUNGI QUESTO CODICE ALL'INIZIO DEL TUO <script type="module"> in index.html

    const firebaseConfig = {
      apiKey: "AIzaSyBbjK5sgQ70-p8jODaK_PnLIzPxgfrqQ34",
      authDomain: "archivio-clienti-trasporti.firebaseapp.com",
      projectId: "archivio-clienti-trasporti",
      storageBucket: "archivio-clienti-trasporti.firebasestorage.app",
      messagingSenderId: "773533170263",
      appId: "1:773533170263:web:d05e2b00e991b0294c0112"
    };

    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import {
      getFirestore, collection, addDoc, deleteDoc, doc, setDoc, updateDoc,
      onSnapshot, query, getDocs, getDoc, where, orderBy, serverTimestamp, limit
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
    import {
      getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword,
      onAuthStateChanged, signOut, updateProfile
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    // üîî IMPORT MESSAGING (nuovo)
    import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-messaging.js";
    import { arrayUnion } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);
    const auth = getAuth(app);

    const ADMIN_UID = "0dCvHDcVp1PHuWVNIN9i6ZvEVBt2";

    const clientiRef   = collection(db, "clienti");
    const posizioniRef = collection(db, "posizioniMezzo");

    let nomeUtente = ""; // letto da Firestore o email
    let clienteDaModificare = null;
    let watchId = null;

    // üîî Variabili per il contatore chat
    let chatUnsub = null;
    let currentUserId = null;
    let lastMessageCount = 0; // Per tracciare nuovi messaggi

    // üçû Sistema Toast per messaggi
    function createToast(title, message, onClick) {
      const container = document.getElementById('toast-container');
      if (!container) return;

      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.innerHTML = `
        <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
        <div class="toast-header">
          <span>üí¨</span>
          ${title}
        </div>
        <div class="toast-body">${message}</div>
      `;

      // Click per aprire chat
      if (onClick) {
        toast.addEventListener('click', (e) => {
          if (e.target.classList.contains('toast-close')) return;
          onClick();
          hideToast(toast);
        });
      }

      container.appendChild(toast);
      
      // Anima l'entrata
      setTimeout(() => toast.classList.add('show'), 100);
      
      // Auto-hide dopo 6 secondi
      setTimeout(() => hideToast(toast), 6000);
      
      return toast;
    }

    function hideToast(toast) {
      toast.classList.add('hide');
      setTimeout(() => {
        if (toast.parentElement) {
          toast.remove();
        }
      }, 300);
    }

    function showMessageToast(senderName, messageText) {
      const truncatedMessage = messageText.length > 80 
        ? messageText.substring(0, 80) + '...' 
        : messageText;
        
      createToast(
        `Nuovo messaggio da ${senderName}`,
        truncatedMessage,
        () => {
          // Apri la chat quando clicchi sul toast
          window.location.href = 'chat.html';
        }
      );
    }

    let clientiUnsub = null;
    function startClientiListener() {
      if (clientiUnsub) return;
      const q = query(clientiRef);
      clientiUnsub = onSnapshot(q, mostraClienti, (err) => console.error(err));
    }
    function stopClientiListener() { if (clientiUnsub) { clientiUnsub(); clientiUnsub = null; } }

    // üîî Funzioni per gestire il contatore chat - CORRETTE per readBy come ARRAY
    function startChatListener(userId) {
      if (chatUnsub) return;
      
      // Query per messaggi nel thread dell'utente (ultimi 50 per performance)
      const threadMessagesRef = collection(db, "threads", userId, "messages");
      const q = query(threadMessagesRef, orderBy("createdAt", "desc"), limit(50));
      
      chatUnsub = onSnapshot(q, (snapshot) => {
        let unreadCount = 0;
        let latestUnreadMessage = null;
        const currentTime = Date.now();
        
        snapshot.forEach(doc => {
          const msg = doc.data();
          // Conta solo i messaggi ricevuti (non inviati dall'utente corrente)
          if (msg.sender !== userId) {
            const readBy = Array.isArray(msg.readBy) ? msg.readBy : [];
            if (!readBy.includes(userId)) {
              unreadCount++;
              
              // Trova il messaggio non letto pi√π recente per il toast
              if (!latestUnreadMessage) {
                const msgTime = msg.createdAt?.toDate?.()?.getTime() || 0;
                // Mostra toast solo per messaggi degli ultimi 30 secondi
                if (currentTime - msgTime < 30000) {
                  latestUnreadMessage = msg;
                }
              }
            }
          }
        });
        
        // Mostra toast solo se ci sono nuovi messaggi (non al caricamento iniziale)
        if (latestUnreadMessage && lastMessageCount < unreadCount && lastMessageCount > 0) {
          // Solo se la pagina √® visibile e attiva
          if (!document.hidden && document.hasFocus()) {
            showMessageToast('Admin', latestUnreadMessage.text || 'Nuovo messaggio');
          }
        }
        
        lastMessageCount = unreadCount;
        updateChatCounter(unreadCount);
        console.log(`üîî Messaggi non letti: ${unreadCount}`);
      }, (err) => console.error("Errore listener chat:", err));
    }

    function stopChatListener() {
      if (chatUnsub) {
        chatUnsub();
        chatUnsub = null;
        lastMessageCount = 0; // Reset contatore messaggi
      }
    }

    function updateChatCounter(count) {
      const counter = document.getElementById('chat-counter');
      
      if (count > 0) {
        counter.textContent = count > 99 ? '99+' : count;
        counter.classList.remove('hidden');
        
        // Aggiungi animazione per nuovi messaggi
        counter.classList.add('new-message');
        setTimeout(() => counter.classList.remove('new-message'), 1000);
        
        // Cambia il titolo della pagina per notificare
        document.title = `(${count}) Archivio Clienti - Trasporti`;
      } else {
        counter.classList.add('hidden');
        document.title = 'Archivio Clienti - Trasporti';
      }
    }

    // üîî Segna messaggi come letti quando si clicca sulla chat - CORRETTO per ARRAY
    document.getElementById('chat-link').addEventListener('click', async (e) => {
      if (currentUserId) {
        try {
          // Riferimento ai messaggi del thread dell'utente
          const threadMessagesRef = collection(db, "threads", currentUserId, "messages");
          const q = query(threadMessagesRef);
          
          const snapshot = await getDocs(q);
          
          // Segna tutti i messaggi ricevuti come letti
          const batch = [];
          snapshot.forEach((doc) => {
            const msg = doc.data();
            // Solo messaggi ricevuti (non inviati dall'utente corrente)
            if (msg.sender !== currentUserId) {
              const readBy = Array.isArray(msg.readBy) ? msg.readBy : [];
              // Se l'utente non √® gi√† nell'array readBy, aggiungilo
              if (!readBy.includes(currentUserId)) {
                batch.push(updateDoc(doc.ref, { 
                  readBy: arrayUnion(currentUserId) 
                }));
              }
            }
          });
          
          if (batch.length > 0) {
            await Promise.all(batch);
            console.log('‚úÖ Messaggi segnati come letti');
          }
        } catch (error) {
          console.error('Errore nel segnare messaggi come letti:', error);
        }
      }
    });

    let userUnsub = null;
    const el = (id) => document.getElementById(id);
    const show = (node) => { node.style.display = (node.id === 'auth-overlay' || node.id === 'awaiting-approval') ? 'flex' : 'block'; };
    const hide = (node) => node.style.display = 'none';
    function enableAppUI() { show(el("app-wrapper")); hide(el("auth-overlay")); hide(el("awaiting-approval")); }
    function disableAppUI() { hide(el("app-wrapper")); }
    function authErrorMsg(e) {
      switch (e?.code) {
        case 'auth/weak-password': return 'La password deve avere almeno 6 caratteri.';
        case 'auth/email-already-in-use': return 'Questa email √® gi√† registrata. Prova ad accedere.';
        case 'auth/invalid-email': return 'Email non valida.';
        case 'auth/invalid-credential': return 'Credenziali non valide.';
        case 'auth/network-request-failed': return 'Problema di rete. Controlla la connessione.';
        default: return e?.message || 'Errore imprevisto.';
      }
    }
    const disableBtn = (btn, on) => btn.disabled = !!on;

    function renderUserBar(uAuth, uData) {
      const box = document.getElementById("userbar");
      if (!box) return;
      const name  = (uData?.name || uAuth?.displayName || (uAuth?.email ? uAuth.email.split("@")[0] : "")).trim();
      const email = uAuth?.email || "";
      const role  = (uData?.role) || (uAuth?.uid === ADMIN_UID ? "admin" : "driver");
      box.innerHTML = `üë§ <strong>${name || "(senza nome)"}</strong>
                       <span class="pill">${email}</span>
                       <span class="pill">${role}</span>`;
    }

    const tabLogin = el("tab-login");
    const tabRegister = el("tab-register");
    const paneLogin = el("pane-login");
    const paneRegister = el("pane-register");
    const authHeader = el("auth-header");

    function switchAuth(mode) {
      if (mode === "login") {
        paneLogin.style.display = "block";
        paneRegister.style.display = "none";
        tabLogin.classList.add("active");
        tabRegister.classList.remove("active");
        authHeader.textContent = "Accesso";
      } else {
        paneLogin.style.display = "none";
        paneRegister.style.display = "block";
        tabRegister.classList.add("active");
        tabLogin.classList.remove("active");
        authHeader.textContent = "Registrazione";
      }
    }
    tabLogin.addEventListener("click", () => switchAuth("login"));
    tabRegister.addEventListener("click", () => switchAuth("register"));
    function showAuth(defaultTab = "login") { disableAppUI(); show(el("auth-overlay")); switchAuth(defaultTab); }

    // REGISTRAZIONE
    el("btn-register").addEventListener("click", async () => {
      const name = el("reg-name").value.trim();
      const email = el("reg-email").value.trim();
      const password = el("reg-password").value;
      if (!name || !email || !password) { alert("Compila nome, email e password."); return; }
      if (password.length < 6) { alert("La password deve avere almeno 6 caratteri."); return; }
      disableBtn(el("btn-register"), true);
      try {
        const cred = await createUserWithEmailAndPassword(auth, email, password);
        await updateProfile(cred.user, { displayName: name });
        await setDoc(doc(db, "users", cred.user.uid), {
          name, email, role: "driver", approved: false, createdAt: serverTimestamp()
        });
        alert("Registrazione completata! Ora attendi l'approvazione dell'amministratore.");
      } catch (e) {
        alert("Registrazione non riuscita: " + authErrorMsg(e));
      } finally {
        disableBtn(el("btn-register"), false);
      }
    });

    // LOGIN
    el("btn-login").addEventListener("click", async () => {
      const email = el("log-email").value.trim();
      const password = el("log-password").value;
      if (!email || !password) { alert("Inserisci email e password."); return; }
      disableBtn(el("btn-login"), true);
      try { await signInWithEmailAndPassword(auth, email, password); }
      catch (e) { alert("Accesso non riuscito: " + authErrorMsg(e)); }
      finally { disableBtn(el("btn-login"), false); }
    });

    // LOGOUT
    el("btn-logout").addEventListener("click", () => signOut(auth));
    el("btn-logout-while-waiting").addEventListener("click", () => signOut(auth));

    // üîî --- PUSH MESSAGING (FCM) ---
    const messaging = getMessaging(app);
    const VAPID_PUBLIC_KEY = "BG1pU9CLPvIoAwBKbUFtveLXiX8EgSqzUyuoVl465d5zuSzyQZN043nfnN1xamZuDa9gZZEbsNpT-Vs_m_x-nS0";

    // Registra il service worker FCM e salva il token su Firestore per l'utente indicato.
    async function enablePushForUser(user){
      try {
        // Verifica compatibilit√†
        if (!('Notification' in window) || !('serviceWorker' in navigator)) {
          console.warn('Notifiche o Service Worker non supportati');
          return;
        }
        // Registra il service worker con percorso relativo corretto
        const swReg = await navigator.serviceWorker.register('firebase-messaging-sw.js').catch((err) => {
          console.warn('Registrazione service worker FCM fallita:', err);
          throw err;
        });
        // Richiedi permesso per le notifiche (dopo interazione utente)
        const perm = await Notification.requestPermission();
        if (perm !== 'granted') {
          console.warn('Permesso notifiche negato');
          return;
        }
        // Ottieni token FCM passando la registrazione del service worker
        const token = await getToken(messaging, { vapidKey: VAPID_PUBLIC_KEY, serviceWorkerRegistration: swReg });
        if (!token) {
          console.warn('Nessun token FCM ricevuto (controlla HTTPS e firebase-messaging-sw.js)');
          return;
        }
        // Salva token nell'utente su Firestore
        await setDoc(doc(db, "users", user.uid), { fcmTokens: { [token]: true } }, { merge: true });
        console.log('‚úÖ FCM token salvato per', user.uid);
      } catch (e) {
        console.warn('Errore during enablePushForUser', e);
      }
    }

    // Gestisce la richiesta di permesso e la visibilit√† del pulsante per le notifiche push.
    async function handlePushPermission(user) {
      // Se notifiche o service worker non sono supportati non fare nulla
      if (!('Notification' in window) || !('serviceWorker' in navigator)) {
        return;
      }
      const wrapper = document.getElementById('push-activation-wrapper');
      const btn = document.getElementById('btn-enable-push');
      // Se permesso gi√† concesso, registra direttamente
      if (Notification.permission === 'granted') {
        if (wrapper) wrapper.style.display = 'none';
        await enablePushForUser(user);
      } else {
        // Mostra il pulsante di attivazione
        if (wrapper) wrapper.style.display = 'block';
        if (btn) {
          btn.onclick = async () => {
            btn.disabled = true;
            try {
              await enablePushForUser(user);
            } finally {
              // Nascondi il pulsante dopo il tentativo
              if (wrapper) wrapper.style.display = 'none';
              btn.disabled = false;
            }
          };
        }
      }
    }

    onMessage(messaging, (payload) => {
      console.log('üì® Push in foreground:', payload);
      
      // Mostra toast per notifiche push in foreground
      if (payload.notification) {
        const title = payload.notification.title || 'Nuovo messaggio';
        const body = payload.notification.body || '';
        
        createToast(title, body, () => {
          // Apri la chat quando clicchi sul toast
          window.location.href = 'chat.html';
        });
      }
    });

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        showAuth("login");
        stopClientiListener();
        stopChatListener(); // üîî Stop chat listener
        currentUserId = null; // üîî Reset current user
        updateChatCounter(0); // üîî Reset counter
        if (userUnsub) { userUnsub(); userUnsub = null; }
        const ub = document.getElementById("userbar"); if (ub) ub.innerHTML = "";
        return;
      }

      currentUserId = user.uid; // üîî Set current user ID

      const uref = doc(db, "users", user.uid);
      const snap = await getDoc(uref);

      if (!snap.exists()) {
        await setDoc(uref, {
          name: user.displayName || "",
          email: user.email,
          role: (user.uid === ADMIN_UID) ? "admin" : "driver",
          approved: (user.uid === ADMIN_UID) ? true : false,
          createdAt: serverTimestamp()
        }, { merge: true });
      } else {
        const dataNow = snap.data() || {};
        if (!("role" in dataNow)) {
          await updateDoc(uref, { role: (user.uid === ADMIN_UID) ? "admin" : "driver" });
        }
        await setDoc(uref, {
          name: dataNow.name || user.displayName || "",
          email: dataNow.email || user.email || ""
        }, { merge: true });
      }

      if (userUnsub) { userUnsub(); userUnsub = null; }
      userUnsub = onSnapshot(uref, (usnap) => {
        const data = usnap.data() || {};
        nomeUtente = (data.name || (user.email ? user.email.split("@")[0] : "")).trim();
        renderUserBar(user, data);

        if (data.role === "driver" && data.approved === true) {
          enableAppUI(); 
          startClientiListener();
          startChatListener(user.uid); // üîî Start chat listener
          // üîî abilita push per driver approvato tramite gestione permessi
          handlePushPermission(user);
        } else if (data.role === "admin") {
          disableAppUI(); hide(el("auth-overlay")); show(el("awaiting-approval"));
          el("awaiting-approval").innerHTML =
            "<h3>üëë Sei loggato come admin</h3><div>L'app operativa √® solo per gli autisti approvati. Vai su <a href='admin.html'>admin.html</a>.</div><button id='btn-logout-while-waiting' style='margin-top:6px; max-width:200px;'>Esci</button>";
          document.getElementById('btn-logout-while-waiting').onclick = () => signOut(auth);
          stopClientiListener();
          stopChatListener(); // üîî Stop chat listener for admin
          // (opzionale) abilita push anche per admin tramite gestione permessi
          handlePushPermission(user);
        } else {
          disableAppUI(); hide(el("auth-overlay")); show(el("awaiting-approval"));
          el("awaiting-approval").querySelector("h3").textContent = "‚è≥ Account in attesa di approvazione";
          stopClientiListener();
          stopChatListener(); // üîî Stop chat listener for unapproved users
        }
      });
    });

    async function aggiungiOmodificaCliente() {
      const nome = el("nome").value;
      const indirizzo = el("indirizzo").value;
      const coordinate = el("coordinate").value;
      const note = el("note").value;
      if (!nome || !indirizzo) { alert("Inserisci almeno nome e indirizzo."); return; }

      if (clienteDaModificare) {
        const docRef = doc(db, "clienti", clienteDaModificare);
        try {
          await updateDoc(docRef, { nome, indirizzo, coordinate, note });
          clienteDaModificare = null;
          el("btn-aggiungi").innerText = "Aggiungi cliente";
          el("btn-annulla").style.display = "none";
        } catch (error) {
          alert("Impossibile salvare le modifiche: il cliente non esiste pi√π.");
          console.error(error);
        }
      } else {
        await addDoc(clientiRef, { nome, indirizzo, coordinate, note, timestamp: serverTimestamp() });
      }
      el("nome").value = ""; el("indirizzo").value = ""; el("coordinate").value = ""; el("note").value = "";
    }

    async function eliminaCliente(id) {
      if (confirm("Sei sicuro di voler eliminare questo cliente?")) {
        await deleteDoc(doc(db, "clienti", id));
      }
    }

    function preparaModificaCliente(id, cliente) {
      el("nome").value = cliente.nome; el("indirizzo").value = cliente.indirizzo;
      el("coordinate").value = cliente.coordinate || ""; el("note").value = cliente.note || "";
      clienteDaModificare = id; el("btn-aggiungi").innerText = "Salva modifiche"; el("btn-annulla").style.display = "inline-block";
    }

    function annullaModifica() {
      clienteDaModificare = null;
      el("nome").value = ""; el("indirizzo").value = ""; el("coordinate").value = ""; el("note").value = "";
      el("btn-aggiungi").innerText = "Aggiungi cliente"; el("btn-annulla").style.display = "none";
    }

    function mostraClienti(snapshot) {
      const clientiDiv = el("clienti"); clientiDiv.innerHTML = "";
      snapshot.forEach(docSnap => {
        const c = docSnap.data();
        const div = document.createElement("div");
        div.className = "cliente";
        div.innerHTML = `<strong>${c.nome || "(senza nome)"}</strong><br>
                         ${c.indirizzo || ""}<br>
                         ${c.coordinate ? `<a href='https://maps.google.com/?q=${c.coordinate}' target='_blank'>Vai a Google Maps</a><br>` : ""}
                         ${c.note ? `<em>${c.note}</em><br>` : ""}
                         <button class='btn-azione' onclick='eliminaCliente("${docSnap.id}")'>üóëÔ∏è Elimina</button>
                         <button class='btn-azione' onclick='preparaModificaCliente("${docSnap.id}", ${JSON.stringify(c).replace(/"/g, '&quot;')})'>‚úèÔ∏è Modifica</button>`;
        clientiDiv.appendChild(div);
      });
    }

    function filtraClienti() {
      const queryTxt = el("cerca").value.toLowerCase();
      const clienti = document.querySelectorAll(".cliente");
      clienti.forEach(c => { c.style.display = c.innerText.toLowerCase().includes(queryTxt) ? "block" : "none"; });
    }

    el("btn-aggiungi").addEventListener("click", aggiungiOmodificaCliente);
    el("btn-annulla").addEventListener("click", annullaModifica);
    el("cerca").addEventListener("input", filtraClienti);

    el("btn-gps").addEventListener("click", () => {
      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
          async position => {
            const coords = `${position.coords.latitude.toFixed(6)}, ${position.coords.longitude.toFixed(6)}`;
            el("coordinate").value = coords;
            if (nomeUtente) {
              await addDoc(posizioniRef, {
                // üîê suggerito: salva anche l'uid del proprietario posizione
                uid: auth.currentUser?.uid || null,
                mezzo: nomeUtente,
                latitudine: position.coords.latitude,
                longitudine: position.coords.longitude,
                timestamp: serverTimestamp()
              });
            }
          },
          error => { alert("Impossibile ottenere la posizione. Assicurati che il GPS sia attivo."); console.error(error); }
        );
      } else { alert("Geolocalizzazione non supportata su questo dispositivo."); }
    });

    // Tracciamento automatico (facoltativo: mantieni la tua implementazione)
    window.avviaTracciamento = function(){
      const status = document.getElementById('status');
      if (!('geolocation' in navigator)) { status.textContent = 'Geolocalizzazione non supportata.'; return; }
      if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; status.textContent = 'Tracciamento disattivato.'; return; }
      watchId = navigator.geolocation.watchPosition(async pos => {
        const { latitude, longitude } = pos.coords;
        status.textContent = `Ultima posizione: ${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
        if (nomeUtente) {
          await addDoc(posizioniRef, {
            uid: auth.currentUser?.uid || null,
            mezzo: nomeUtente,
            latitudine: latitude,
            longitudine: longitude,
            timestamp: serverTimestamp()
          });
        }
      }, err => { status.textContent = 'Errore GPS: ' + err.message; }, { enableHighAccuracy:true, maximumAge:5000 });
    }

    // Espone alcune funzioni globali per i bottoni inline
    window.eliminaCliente = eliminaCliente;
    window.preparaModificaCliente = preparaModificaCliente;

  </script>

  <!-- üîî Registrazione del Service Worker FCM (root: /firebase-messaging-sw.js) -->
  <script>
    if ('serviceWorker' in navigator) {
      // Registra il service worker per FCM con percorso relativo corretto.
      navigator.serviceWorker.register('firebase-messaging-sw.js')
        .catch(err => console.warn('SW (FCM) registration failed', err));
    }
  </script>
</body>
</html>